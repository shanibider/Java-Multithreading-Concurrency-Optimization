Double-checked locking


In software engineering, double-checked locking (also known as "double-checked locking optimization") is a software design pattern 
used to reduce the overhead of acquiring a lock by testing the locking criterion (the "lock hint") before acquiring the lock. 
Locking occurs only if the locking criterion check indicates that locking is required.

The pattern, when implemented in some language/hardware combinations, can be unsafe. At times, it can be considered an anti-pattern.

It is typically used to reduce locking overhead when implementing "lazy initialization" in a multi-threaded environment, 
especially as part of the Singleton pattern. Lazy initialization avoids initializing a value until the first time it is accessed.

-----------------------------------------------------------------------------------------------------------------------------------

// 1. Single-threaded version
class Foo {
    private Helper helper;
    public Helper getHelper() {
        if (helper == null) {
            helper = new Helper();
        }
        return helper;
    }
}
The problem is that this does not work when using multiple threads. 
A lock must be obtained in case two threads call getHelper() simultaneously. 
Otherwise, either they may both try to create the object at the same time, 
or one may wind up getting a reference to an incompletely initialized object.

-----------------------------------------------------------------------------------------------------------------------------------

// 2. Correct but possibly expensive multithreaded version
class Foo {
    private Helper helper;
    public synchronized Helper getHelper() {
        if (helper == null) {
            helper = new Helper();
        }
        return helper;
    }
}
However, the first call to getHelper() will create the object and only the few
 threads trying to access it during that time need to be synchronized; 
 after that all calls just get a reference to the member variable. 
 Since synchronizing a method could in some extreme cases decrease performance by a factor of 100 or higher, 
 the overhead of acquiring and releasing a lock every time this method is called seems unnecessary: 
 once the initialization has been completed, acquiring and releasing the locks would appear unnecessary. 
 Many programmers have attempted to optimize this situation in the following manner:

1. Check that the variable is initialized (without obtaining the lock). If it is initialized, return it immediately.
2. Obtain the lock.
3. Double-check whether the variable has already been initialized: if another thread acquired the lock first, 
   it may have already done the initialization. If so, return the initialized variable.
4. Otherwise, initialize and return the variable.

-----------------------------------------------------------------------------------------------------------------------------------

// 3. Broken multithreaded version
// "Double-Checked Locking" idiom
class Foo {
    private Helper helper;
    public Helper getHelper() {
        if (helper == null) {
            synchronized (this) {
                if (helper == null) {
                    helper = new Helper();
                }
            }
        }
        return helper;
    }
}

Intuitively, this algorithm seems like an efficient solution to the problem. 
However, this technique has many subtle problems and should usually be avoided. 
For example, consider the following sequence of events:

1. Thread A notices that the value is not initialized, so it obtains the lock and begins to initialize the value.
2. Due to the semantics of some programming languages, the code generated by the compiler is allowed to 
   update the shared variable to point to a partially constructed object before A has finished performing the initialization. 
   For example, in Java if a call to a constructor has been inlined then the shared variable 
   may immediately be updated once the storage has been allocated but before the inlined constructor initializes the object.
3. Thread B notices that the shared variable has been initialized (or so it appears), 
   and returns its value. Because thread B believes the value is already initialized, 
   it does not acquire the lock. If B uses the object before all of the initialization done by A is seen by B 
   (either because A has not finished initializing it or because some of the initialized values in the 
   object have not yet percolated to the memory B uses (cache coherence)), the program will likely crash.

-----------------------------------------------------------------------------------------------------------------------------------

// 4. Correct lazy initialization in Java
class Foo {
    private static class HelperHolder {
       public static final Helper helper = new Helper();
    }

    public static Helper getHelper() {
        return HelperHolder.helper;
    }
}

This relies on the fact that nested classes are not loaded until they are referenced.